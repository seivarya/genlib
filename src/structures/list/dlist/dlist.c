/* dlist.c: doubly linked list methods */

#include <stdlib.h>
#include <stdio.h>
#include <genlib/td.h>
#include <genlib/dlist.h>

#include "dnode/dnode.h" 

/* info: private methods */

static inline int _validate_dlist_ptr(dlist *list) {
	if (list == NULL) {
		fprintf(stderr, "Error: %s: Doubly linked list pointer is NULL.\n", __func__);
		return 0;
	}
	return 1;
}

static inline int _validate_dindex(dlist *list, size_t index) {
	if (list == NULL) {
		fprintf(stderr, "Error: %s: Doubly linked list pointer is NULL for index validation.\n", __func__);
		return 0;
	}
	if (index >= list->length) {
		fprintf(stderr, "Error: %s: Index %zu out of bounds for list length %zu.\n", __func__, index, list->length);
		return 0;
	}
	return 1;
}

static dnode* _dlist_iterate(dlist *list, size_t index) {
	if (!_validate_dindex(list, index))
		return NULL;

	size_t mid_index = list->length / 2;
	dnode *cursor;

	/* iterate: optimized */
	if (index <= mid_index) {
		cursor = list->head;
		while (index != 0) {
			cursor = cursor->next;
			index--;
		}
	} else {
		cursor = list->tail;
		while (index != 0) {
			cursor = cursor->previous;
			index--;
		}
	}

	return cursor;
}

/* info: public methods */

dlist* dlist_construct(void) {
	dlist *list = malloc(sizeof(dlist));
	if (list) {
		list->head = NULL;
		list->tail = NULL;
		list->length = 0;
		return list;
	}
	fprintf(stderr, "=== error: dlist_construct(): malloc failed ===\n");
	return NULL;
}

void dlist_destruct(dlist *list) {
	if (!_validate_dlist_ptr(list))
		return;

	dnode *current = list->head;
	while (current != NULL) {
		dnode *next = current->next;
		dnode_destruct(current);
		current = next;
	}

	free(list);
}

void dlist_insert(dlist *list, size_t index, void *data, const td *type) {
	if (!_validate_dlist_ptr(list))
		return;

		if (index > list->length) {
		fprintf(stderr, "Error: %s: Index %zu is out of bounds (length %zu).\n", __func__, index, list->length);
		return;
	}

	dnode *new_node = dnode_construct(data, type);
	if (!new_node)
		return;

	/* case 1: insert at head */
	if (index == 0) {
		if (list->length == 0) {
			list->head = list->tail = new_node;
		} else {
			new_node->next = list->head;
			new_node->previous = NULL;
			list->head->previous = new_node;
			list->head = new_node;
		}
	}

	/* case 2: insert at tail */
	else if (index == list->length) {
		new_node->previous = list->tail;
		list->tail->next = new_node;
		list->tail = new_node; /* new_node->next: NULL: default */
	}

	/* case 3: insert in the middle */
	else {
		dnode *on_index_node = _dlist_iterate(list, index);
		new_node->previous = on_index_node->previous;
		new_node->next = on_index_node;

		on_index_node->previous->next = new_node;
		on_index_node->previous = new_node;
	}

	list->length++;
}

void dlist_remove(dlist *list, size_t index) {
	if (!_validate_dindex(list, index))
		return;

	dnode *target;

	/* case 1: removing the head */
	if (index == 0) {
		target = list->head;

		if (list->length < 2) {
			list->head = NULL;
			list->tail = NULL;
		} else {
			list->head = target->next;
			list->head->previous = NULL;
		}
	}

	/* case 2: removing the tail */
	else if (index == list->length - 1) {
		target = list->tail;

		list->tail->previous->next = NULL;
		list->tail = list->tail->previous;
	}

	/* case 3: removing from middle */
	else {
		target = _dlist_iterate(list, index);

		target->previous->next = target->next;
		target->next->previous = target->previous;
	}

	dnode_destruct(target);
	list->length--;
}

void* dlist_fetch_node(dlist *list, size_t index) {
	if (!_validate_dindex(list, index)) return NULL;

	dnode *node = _dlist_iterate(list, index);
	if (!node) { fprintf(stderr, "Error: %s: Node not found at index %zu.\n", __func__, index); }
	return node;
}

void dlist_print(dlist *list) {
	if (!_validate_dlist_ptr(list))
		return;

	if (list->length == 0) {
		fprintf(stderr, "Error: %s: Doubly linked list is empty, cannot print.\n", __func__);
		return;
	}

	dnode *current = list->head;
	while (current != NULL) {
		const td *type = current->type;
		if (type && type->print) {
			type->print(current->data);
		} else {
			fprintf(stderr, "Warning: %s: No print function available for data type at node %p.\n", __func__, (void*)current);
		}
		current = current->next;
	}
} /* dlist_c */
